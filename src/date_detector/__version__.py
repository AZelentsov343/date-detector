__version__ = "0.post5"
__git_commiter_name__ = "Itai Shirav"
__git_commiter_email__ = "itais@infinidat.com"
__git_branch__ = u'develop'
__git_remote_tracking_branch__ = u'origin/develop'
__git_remote_url__ = u'git@github.com:ishirav/date-detector.git'
__git_head_hash__ = '638e7929e4c86eb65600f8c2110b3cf00fb1cf6c'
__git_head_subject__ = u'python 3 compatibility remove print statements'
__git_head_message__ = u''
__git_dirty_diff__ = u"diff --git a/buildout.cfg b/buildout.cfg\nindex 8d796c0..0ebeeee 100644\n--- a/buildout.cfg\n+++ b/buildout.cfg\n@@ -4,13 +4,16 @@ newest = false\n extensions = buildout.wheel\n download-cache = .cache\n develop = .\n-parts =\n+parts = \n \n [project]\n name = date-detector\n company = Infinidat\n namespace_packages = []\n-install_requires = ['setuptools']\n+install_requires = [\n+\t'setuptools',\n+\t'six'\n+\t]\n version_file = src/date_detector/__version__.py\n description = A Python module for scanning text and extracting dates from it\n long_description = A Python module for scanning text and extracting dates from it\ndiff --git a/src/date_detector/detector.py b/src/date_detector/detector.py\nindex bc0af67..3d7c623 100644\n--- a/src/date_detector/detector.py\n+++ b/src/date_detector/detector.py\n@@ -24,6 +24,8 @@ class Tokenizer(object):\n     WHITESPACE  = 'W'\n     OTHER       = 'O'\n \n+    WHITESPACE_CHARS = ' \\t\\n\\r'.encode('ascii')\n+\n     def tokenize(self, text):\n         token_start = token_end = 0\n         token_type = None\n@@ -53,7 +55,7 @@ class Tokenizer(object):\n             return self.DIGITS\n         if char.isalpha():\n             return self.LETTERS\n-        if char in (' \\t\\n\\r'):\n+        if char in self.WHITESPACE_CHARS:\n             return self.WHITESPACE\n         return self.OTHER\n \n@@ -68,9 +70,6 @@ class Sequence(object):\n         self.tokens = []\n         self.entries = []\n \n-    def __unicode__(self):\n-        return self.text[self.get_start() : self.get_end()]\n-\n     def __repr__(self):\n         return '/'.join([self.text[t.start : t.end] for t in self.tokens])\n \n@@ -93,6 +92,9 @@ class Sequence(object):\n     def get_end(self):\n         return self.tokens[-1].end\n \n+    def get_text(self):\n+        return self.text[self.get_start() : self.get_end()]\n+\n \n class Parser(object):\n \n@@ -113,6 +115,7 @@ class Parser(object):\n             # Look for the token text in the dictionaries\n             token_text = self._extract_token(text, token)\n             entry = self.entries.get(token_text)\n+            print token_text, entry\n             if entry is None:\n                 # Token not identified, end of current token sequence (if any)\n                 for match in self._build_matches(seq):\n@@ -150,19 +153,6 @@ class Parser(object):\n             token_text = token_text.strip()\n         return token_text\n \n-    def _extend(self, candidates, entry):\n-        new_candidates = []\n-        if entry.year:\n-            # Create new candidates by filling their year field\n-            new_candidates.extend([Candidate(entry.year, c.month, c.day) for c in candidates if not c.year])\n-        if entry.month:\n-            # Create new candidates by filling their month field\n-            new_candidates.extend([Candidate(c.year, entry.month, c.day) for c in candidates if not c.month])\n-        if entry.day:\n-            # Create new candidates by filling their day field\n-            new_candidates.extend([Candidate(c.year, c.month, entry.day) for c in candidates if not c.day])\n-        return new_candidates\n-\n     def _build_matches(self, seq):\n         matches = set()\n         if seq.is_full():\n@@ -170,8 +160,10 @@ class Parser(object):\n             for candidate in candidates:\n                 try:\n                     d = date(*candidate)\n-                    matches.add(Match(date=d, offset=seq.get_start(), text=str(seq)))\n-                except Exception as e:\n+                    matches.add(Match(date=d, offset=seq.get_start(), text=seq.get_text()))\n+                # except Exception as e:\n+                #     print e\n+                finally:\n                     pass\n         return matches\n \n@@ -193,6 +185,19 @@ class Parser(object):\n             candidates = self._extend(candidates, entry)\n         return candidates\n \n+    def _extend(self, candidates, entry):\n+        new_candidates = []\n+        if entry.year:\n+            # Create new candidates by filling their year field\n+            new_candidates.extend([Candidate(entry.year, c.month, c.day) for c in candidates if not c.year])\n+        if entry.month:\n+            # Create new candidates by filling their month field\n+            new_candidates.extend([Candidate(c.year, entry.month, c.day) for c in candidates if not c.month])\n+        if entry.day:\n+            # Create new candidates by filling their day field\n+            new_candidates.extend([Candidate(c.year, c.month, entry.day) for c in candidates if not c.day])\n+        return new_candidates\n+\n     def _add_to_dictionary(self, token, year=None, month=None, day=None):\n         token = token.lower()\n         old_entry = self.entries.get(token)\n@@ -231,7 +236,6 @@ class Parser(object):\n     def _load_dictionary(self, name):\n         from pkgutil import get_data\n         text = get_data('date_detector', 'dictionaries/%%s.txt' %% name)\n-        if not text: return # FIXME\n         for line in text.decode('utf-8').splitlines():\n             line = line.strip()\n             if not line or line[0] == '#':\ndiff --git a/src/date_detector/dictionaries/en.txt b/src/date_detector/dictionaries/en.txt\nindex 359d955..8237889 100644\n--- a/src/date_detector/dictionaries/en.txt\n+++ b/src/date_detector/dictionaries/en.txt\n@@ -29,3 +29,4 @@ st             -    -    -\n nd             -    -    -\n rd             -    -    -\n th             -    -    -\n+of             -    -    -\ndiff --git a/src/tests/test_parser.py b/src/tests/test_parser.py\nindex 863b908..944b203 100644\n--- a/src/tests/test_parser.py\n+++ b/src/tests/test_parser.py\n@@ -1,3 +1,6 @@\n+# -*- coding: utf-8 -*-\n+from __future__ import unicode_literals\n+\n from unittest import TestCase\n \n from date_detector import Parser\n@@ -38,6 +41,16 @@ class ParserTest(TestCase):\n             self._check(p, '9 October, 2017', ['2017-10-09'])\n             self._check(p, '2017 October 9', ['2017-10-09'])\n \n+    def test_hebrew(self):\n+        for month_before_day in (False,):\n+            p = Parser(dictionaries=('en', 'he'), month_before_day=month_before_day)\n+            self._check(p, '\u05d0\u05d5\u05e7\u05d8\u05d5\u05d1\u05e8 9, 2017', ['2017-10-09'])\n+            self._check(p, '9 \u05d0\u05d5\u05e7\u05d8\u05d5\u05d1\u05e8 2017', ['2017-10-09'])\n+            self._check(p, '\u05d4-9 \u05dc\u05d0\u05d5\u05e7\u05d8\u05d5\u05d1\u05e8, 2017', ['2017-10-09'])\n+            self._check(p, '\u05d4-9 \u05d1\u05d0\u05d5\u05e7\u05d8\u05d5\u05d1\u05e8, 2017', ['2017-10-09'])\n+            self._check(p, '2017-\u05d0\u05d5\u05e7-09', ['2017-10-09'])\n+            self._check(p, '2017 \u05d0\u05d5\u05e7\u05d8\u05d5\u05d1\u05e8 9', ['2017-10-09'])\n+\n     def test_invalid_dates(self):\n         for month_before_day in (True, False):\n             p = Parser(month_before_day=month_before_day)\n"
__git_commit_date__ = '2017-12-27 09:40:30'
